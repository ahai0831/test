
本文档适用于：开发人员。
目的：描述`//test/test_xxx/test_xxx_xxxx/` 内的自测用例源文件编写规范。

修订记录：
2020/4/9 dengjzh1 初稿


此目录为第三方依赖、公共类库、源代码的自测代码目录。


1. 将自测用例组织到正确的目录中
原则上，各大类应放进独立的目录中，不应直接建立需要测试的测试代码目录。
对`//test/`目录下，各子目录进行说明
`//test/test_third_party/` 在此目录中，对其他第三方库，再建立一层子目录，再在其中编写相应的测试用例。
`//test/test_general_restful_sdk/` 在此目录中，对general_restful_sdk，编写相应的测试用例。这些测试用例，一方面说明了，如何使用C++调用此SDK。另一方面，对一些危险的临界条件进行测试，在自测阶段对过去修复过的严重“问题”，进行回归。
`//test/test_cloud189/` 在此目录中，再建一层子目录。比如以`//test/test_third_party/test_apis/` 为例，编写相应的各apis网络请求的测试用例。这些测试用例，一方面说明了，如何使用此接口。另一方面，对一些危险的临界条件进行测试，比如弱网情况下，解析Response中的int322_error_code，返回值是否如实代表网络错误。
`//test/test_family_cloud/` 同上，针对家庭云相关。
`//test/test_enterprise_cloud/` 同上，针对企业云相关。
以后对一个内部项目或一个产品，都有专用的二级子目录。
`//test/_deprecated/` 代表弃用源码的目录。在整理`//test/`目录的过程中，可能会将一些乱七八糟的源码移动到这里面去。原本的工程可能会，编译报错，用到这个工程的研发做好对这部分源码的梳理。


比如，测试开源库libuv的测试代码，应位于`//test/test_third_party/test_libuv/test_uv_fs_scandir`所在的位置，并以此进行处理。

为便于管理，本目录(`//test/build.gn`)仅包含group类型的测试代码，子target再进行相应的target引入。

由于有部分老代码也在本仓库托管。考虑后期逐步清理移动。先阶段新增测试代码应符合上述组织形式。


2. 我们为什么要写测试用例
2.1 要求做什么
写代码之前，或作改动之前，需要先补充完善测试代码，再开始开发。

2.2 为什么这样要求
先摆上结论：1. 保留代码回归用例；2. 通过用例说明（第三方依赖，公共类库等）调用方法。
(1) 思考一下：当改动了一行C++代码，就需要重新打一个企业包去验证？如果出了问题，需要怎么定位到，问题出在哪里？如果又改好了，怎么样才能知道是真正改好了，还是表面改好了？。
如果这几个问题思考得不出正面的结论，那就活该研发效率低，输出少，被产品经理在甩锅PPT中实锤垃圾。
看起来，写测试代码，增加了工作量。但是，这种做法提高了调试效率、排查问题效率，一来一回，就是提升了效能。

(2) 写文档：
很多时候，研发看着之前的公共类库，不知道怎么调用，怪没文档；或者干脆自己造轮子，或者从网上找个野生的代码段往里面怼。
上述的后者就是重复造轮子，并且引入了潜在的产品质量风险。上述的前者则代表了错误的归因思路：前人没写文档，文档写得不清楚。
难道是“巨婴”，什么东西都需要别人喂到嘴里，才能消化？
举个反例，很多开源库，文档都是写得不清楚的（点名libuv），或者是样子货（点名rxcpp），照样几千上万star。这些给星的开发者都是瞎？
正确的归因思路：看看前人有没有留公共类库的测试用例。有，就从测试用例中，学习用法；没有，也无需抱怨，看看相应的函数的注释和内部实现，补上测试用例，方便了自己也造福了后人。
结论：写完备的测试用例，写有意义的测试用例；文档就可以少写很多，并且效果更佳。

2.3 怎么做
1. 测试用例写到正确的地方去。
2. 写一个文档，说明清楚，相应的测试用例，起到了什么作用，是展示用法，还是用于assert特定条件。这个文档可以放在此目录中。


3. 建议：对未熟悉现在的项目结构的开发人员：
3.1. 先根据，`docs\docs\developers_material\***开发指南&&规范***.txt`，挑选一个编译单元写一个测试用例；
3.2. 根据规范文档，优化此编译单元中的源码的实现；关注，每次修改后，是否依然能通过测试，如果测试通不过，就代表这次改动，改出了代码错误，或写的测试用例，是不完备的；
3.3. 根据规范文档进行修改时，发现某一处边界条件，处理得不完备。先别动手修改（参见2.2 (1)的说明）；写好一个测试用例，这个用例会执行到出问题的地方，用例中assert的结果，是true；现在，可以开始优化边界条件的处理了，修改完毕以后再次运行这次新增的用例，assert的结果会变成false。
对3.3的备注：请不要在测试代码中注水；如果写100行代码，居然会有300行测试用例，这样的研发输出是不合理的。要提高代码质量，而不是要大幅减少有效的技术产出。
思考一下：一个高质量的“回归用例”，能触发到复数个临界条件，从而大大减少测试用例的代码量，但对代码质量的保障力度更强。




