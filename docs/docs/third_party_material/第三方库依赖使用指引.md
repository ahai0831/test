
# **第三方库依赖使用指引**

**版权所有  不得翻印  内部资料**

**Version 0.1**

**本文档适用于：开发人员。** 

**目的：描述`//third_party/xxxx/` 内的第三方依赖使用、升级和新增规范。**
  
**修订历史：**

| **版本号** | **时间**  | **作者** | **内容**                                                                            |
| ---------- | --------- | -------- | ----------------------------------------------------------------------------------- |
| 0.1        | 2020.4.9  | 邓健喆     | 创建                                                                                |
| 0.1        | 2020.4.9  | 赵梓同     | 增加内容序号1-6以及附录                          |

# 1.获取编译选项以及源文件

 - 以libuv为例,libuv是一个跨平台、专门写给nodejs的库,提供跨平台文件I/O和线程化功能，去到官网https://dist.libuv.org/dist/下载源码包。
 - 根据官方的makefile和构建过程中去筛选出该第三方依赖的编译选项，再通过脚本去编译整个依赖。
 - 筛选出必须的编译选项，这里脚本筛选编译选项的判断依据仅为该第三方依赖能否编译成功，去掉了官方原有的优化选项。

*官方脚本编译过程输出*
```
sudo make 
Password:
  CC       src/libuv_la-fs-poll.lo
  CC       src/libuv_la-inet.lo
  CC       src/libuv_la-threadpool.lo
  CC       src/libuv_la-uv-data-getter-setters.lo
  CC       src/libuv_la-uv-common.lo
  CC       src/libuv_la-version.lo
  CC       src/unix/libuv_la-async.lo
  CC       src/unix/libuv_la-core.lo
  CC       src/unix/libuv_la-dl.lo
  CC       src/unix/libuv_la-fs.lo
  CC       src/unix/libuv_la-getaddrinfo.lo
  CC       src/unix/libuv_la-getnameinfo.lo
  CC       src/unix/libuv_la-loop-watcher.lo
  CC       src/unix/libuv_la-loop.lo
  CC       src/unix/libuv_la-pipe.lo
  CC       src/unix/libuv_la-poll.lo
  CC       src/unix/libuv_la-process.lo
  CC       src/unix/libuv_la-signal.lo
  CC       src/unix/libuv_la-stream.lo
  CC       src/unix/libuv_la-tcp.lo
  CC       src/unix/libuv_la-thread.lo
  CC       src/unix/libuv_la-timer.lo
  CC       src/unix/libuv_la-tty.lo
  CC       src/unix/libuv_la-udp.lo
  CC       src/unix/libuv_la-bsd-ifaddrs.lo
  CC       src/unix/libuv_la-darwin.lo
  CC       src/unix/libuv_la-darwin-proctitle.lo
  CC       src/unix/libuv_la-fsevents.lo
  CC       src/unix/libuv_la-kqueue.lo
  CC       src/unix/libuv_la-proctitle.lo
  CCLD     libuv.la

```

 - 由官方脚本再结合官方makefile去列出编译所用到的源文件以及编译选项

 *官方脚本部分*
```
@WINNT_FALSE@am__append_5 = include/uv-unix.h
@WINNT_FALSE@am__append_6 = -I$(top_srcdir)/src/unix
@WINNT_FALSE@am__append_7 = src/unix/async.c \
@WINNT_FALSE@                   src/unix/atomic-ops.h \
@WINNT_FALSE@                   src/unix/core.c \
@WINNT_FALSE@                   src/unix/dl.c \
@WINNT_FALSE@                   src/unix/fs.c \
@WINNT_FALSE@                   src/unix/getaddrinfo.c \
@WINNT_FALSE@                   src/unix/getnameinfo.c \
@WINNT_FALSE@                   src/unix/internal.h \
@WINNT_FALSE@                   src/unix/loop-watcher.c \
@WINNT_FALSE@                   src/unix/loop.c \
@WINNT_FALSE@                   src/unix/pipe.c \
@WINNT_FALSE@                   src/unix/poll.c \
@WINNT_FALSE@                   src/unix/process.c \
@WINNT_FALSE@                   src/unix/signal.c \
@WINNT_FALSE@                   src/unix/spinlock.h \
@WINNT_FALSE@                   src/unix/stream.c \
@WINNT_FALSE@                   src/unix/tcp.c \
@WINNT_FALSE@                   src/unix/thread.c \
@WINNT_FALSE@                   src/unix/timer.c \
@WINNT_FALSE@                   src/unix/tty.c \
@WINNT_FALSE@                   src/unix/udp.c

TESTS = test/run-tests$(EXEEXT)
check_PROGRAMS = test/run-tests$(EXEEXT)

# Can't be turned into a CC_CHECK_CFLAGS in configure.ac, it makes compilers
# on other platforms complain that the argument is unused during compilation.
@SUNOS_TRUE@am__append_8 = -pthreads
@WINNT_TRUE@am__append_9 = test/runner-win.c \
@WINNT_TRUE@                          test/runner-win.h

@WINNT_FALSE@am__append_10 = test/runner-unix.c \
@WINNT_FALSE@                          test/runner-unix.h

@AIX_TRUE@am__append_11 = -D_ALL_SOURCE -D_XOPEN_SOURCE=500 -D_LINUX_SOURCE_COMPAT
@LINUX_TRUE@am__append_12 = -D_GNU_SOURCE
@SUNOS_TRUE@am__append_13 = -D__EXTENSIONS__ -D_XOPEN_SOURCE=500
@AIX_TRUE@am__append_14 = -D_ALL_SOURCE \
@AIX_TRUE@                   -D_XOPEN_SOURCE=500 \
@AIX_TRUE@                   -D_LINUX_SOURCE_COMPAT \
@AIX_TRUE@                   -D_THREAD_SAFE \
@AIX_TRUE@                   -DHAVE_SYS_AHAFS_EVPRODS_H
```
# 2.筛选编译选项以及源文件

 - 根据得到的源文件和编译选项编写脚本进行手动编译出一个.a静态库并测试其能力正常与否。
 - 这里存在的不足有两点：
 	- (1).在筛选编译选项的时候，是手动进行屏蔽该编译选项然后进行编译，看编译是否成功，或者说编译成功的.a库是否可用，
 	- (2).去掉了官方原有的g0  -Os等编译优化选项


*手动脚本编译部分代码*

```
function getfile()
{
#循环
    for i in `ls $1`
    
    #判断是文件还是文件夹，如果是文件，就进行编译，否则递归执行该函数
        do
            
        if [ -d $1"/"$i ] #-d 检查文件是否是目录 （[里面必须要有空格隔开]）
            then
                echo "文件夹："${i##*/}
                
                getfile $1"/"$i  #递归
            else
                #echo $dir_or_file
                #判断是不是.c文件，如果是的话就编译此文件
                #多加了x，是为了防止字符串为空时报错。
                if [ "${i##*.}"x = "c"x ]
                then
                    let cnum++
                    
                    ##*/的作用提取文件名
                    echo "编译.c文件:"${i##*/}
                    
                    io=${i/%.c/.o} #创建.o文件，这里用了字符串替换
                    
                    #编译语句
                    sudo clang   -DHAVE_AF_INET6 -DHAVE_ARPA_INET_H -DHAVE_ARPA_NAMESER_COMPAT_H   -DHAVE_ERRNO_H     -DHAVE_GETENV   -DHAVE_IOCTL_FIONBIO -DHAVE_LIMITS_H  -DHAVE_NETDB_H  -DHAVE_RECV -DHAVE_RECVFROM -DHAVE_SEND  -DHAVE_STRUCT_ADDRINFO -DHAVE_STRUCT_SOCKADDR_IN6  -DHAVE_STRUCT_TIMEVAL -DHAVE_SYS_IOCTL_H -DHAVE_WRITEV   -DRECV_TYPE_ARG1=int -DRECV_TYPE_ARG2=void* -DRECV_TYPE_ARG3=size_t -DRECV_TYPE_ARG4=int -DRECV_TYPE_RETV=ssize_t  -DSEND_QUAL_ARG2=const -DSEND_TYPE_ARG1=int -DSEND_TYPE_ARG2=void* -DSEND_TYPE_ARG3=size_t -DSEND_TYPE_ARG4=int -DSEND_TYPE_RETV=ssize_t   -Qunused-arguments -fvisibility=hidden -g0 -Os   -c -o $io $i
                    #${COMPILE} ${io} ${i} #编译
                    #$?判断上一条命令是否成功，成功为0，不成功非0
                    if [ $? -eq 0 ]
                    then
                        echo "编译成功的.o文件是:"${io##*/}
                        careso+="${io##*/} "   #获取zlib的所有.o文件
                        let onum++
                    else
                        echo ${i##*/}"编译.o失败"
                    fi
                fi
        fi
     done
     
}
```
# 3.文档输出

 - 将得到的源文件和编译选项以类似gn构建的形式输出文档，方便gn构建时使用

*文档输出*

```
uv源文件：

sources = [
"src/unix/asy.c",
...
"src/unix/proctitle.c",
...
"src/fs-poll.c",
"src/inet.c",
...
"src/version.c",

]

public = [
"src/unix/linux-syscalls.h",
...
"include/uv-sunos.h",

]


-O2 -pedantic -g -std=gnu89 -Wall -Wextra -Wno-unused-parameter -Wstrict-prototypes

```
# 4.创建文件夹

 - 在electron_download项目中建立第三方库文件夹并规定csv文件。
 - 项目中的python脚本会根据这个csv文件描述去到指定地方使用aria2c下载该库并解压到当前位置。
 - 如果需要升级第三方库版本，`新增`此版本对应的csv文件（按上一个版本对应的csv文件，更换其中的filename,url,sha1信息即可），注意是`新增`此csv文件。另外还需要在build.gn中修改library_version变量。
 - ！注意：这里需要去到csv中相应的url看这个压缩包是否存在

# 5.使用gn构建

 - 建立build.gn文件，根据google官方指引能方便快速的编写gn文件。libuv的build.gn如下。完整文件可到/third_party/libuv/build,gn查看。
 

```
import("//third_party/third_template.gni")

library_version = "libuv-1.20.3"

third_fetch_code("fetch_code") {
  csv_file = library_version + ".csv"

  # Take care of the suffix name
  package_file = library_version + ".tar.gz"
}

third_config("libuv_internal") {
  include_dirs = [
    ".",
    "src",
  ]
  defines = [
    "_WIN32_WINNT=0x0600",
    "_GNU_SOURCE",
  ]
}

third_config("libuv_using") {
  include_dirs = [ "include" ]
  if (is_win) {
    # Windows should be different.
    libs = [
      "Iphlpapi.lib",
      "Psapi.lib",
      "Userenv.lib",
      "ws2_32.lib",
    ]
  }
}

third_static_library("libuv") {
  deps = [
    ":fetch_code",
  ]
  sources = [
    "src/fs-poll.c",
    "src/inet.c",
    "src/threadpool.c",
    "src/uv-common.c",
    "src/version.c",
  ]
  if (is_win) {
    sources += [
      "src/win/async.c",
...
      "src/win/winsock.c",
    ]
  }
  if (is_mac) {
    sources += [
      "src/unix/async.c",
...
      "src/uv-data-getter-setters.c",
    ]
  }
  public = [
    "include/tree.h",
...
    "src/win/winsock.h",
  ]
  configs = [ ":libuv_internal" ]
  public_configs = [ ":libuv_using" ]
}

```

 - Sources 关键字引入源文件，
 - public关键字引入公用头文件，
 - defines关键字引入预编译选项，例如在libcares中，不可或缺的defines选项有:
 

```
if (is_mac) {
    defines += [
      "HAVE_AF_INET6",
      "HAVE_ARPA_INET_H",
      "HAVE_ARPA_NAMESER_COMPAT_H",
      "HAVE_ERRNO_H",
      "HAVE_GETENV",
      "HAVE_IOCTL_FIONBIO",
      "HAVE_LIMITS_H",
      "HAVE_NETDB_H",
      "HAVE_RECV",
      "HAVE_RECVFROM",
      "HAVE_SEND",
      "HAVE_STRUCT_ADDRINFO",
      "HAVE_STRUCT_SOCKADDR_IN6",
      "HAVE_STRUCT_TIMEVAL",
      "HAVE_SYS_IOCTL_H",
      "HAVE_WRITEV",
      "RECV_TYPE_ARG1=int",
      "RECV_TYPE_ARG2=void*",
      "RECV_TYPE_ARG3=size_t",
      "RECV_TYPE_ARG4=int",
      "RECV_TYPE_RETV=ssize_t",
      "SEND_QUAL_ARG2=const",
      "SEND_TYPE_ARG1=int",
      "SEND_TYPE_ARG2=void*",
      "SEND_TYPE_ARG3=size_t",
      "SEND_TYPE_ARG4=int",
      "SEND_TYPE_RETV=ssize_t",
    ]
  }
```

 - 其他所需要的头文件则可以通过configs关键字引入，
 - 通过is_mac和is_win的判断使得gn构建具有跨平台作用，
 - 可能还有些库会用到apple下的框架，否则会编译不通过，这里也得注意下，例如在libcurl中就会用到下面三个库，可以在configs中增加。

```
if (is_mac) {
    libs = [
      "CoreFoundation.framework",
      "Security.framework",
      "LDAP.framework",
    ]
  }
```

 - 以上即完成在项目中通过用gn构建的方式完成了对第三方依赖的引入构建。

# **附录**

> 构建、使用第三方库（此处特指编译为static_library）的六要素：
> 1. 从哪里下载源代码(一般为官网)；
> 2. 将源代码解压到何处（此项目中由python脚本自动下载并解压）；
> 3. 哪些源文件，需要参与编译（需要人工筛选）；
> 4. 编译时，要使用怎样的预处理定义（用作defines），以及其他编译选项(例如cflags)；
> 5. 使用时，哪些头文件会被用到，以及它们被放在哪个目录；
> 6. 使用时，要加哪些预处理定义，以及附加库文件（或附加framework, Mac OS X下）

