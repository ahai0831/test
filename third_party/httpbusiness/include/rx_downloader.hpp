#pragma once
#ifndef _RX_DOWNLOADER_HH
#define _RX_DOWNLOADER_HH
#ifdef _MSC_VER
#pragma warning(disable : 4503)
#endif

#include <atomic>
#include <cinttypes>
#include <functional>

#include <rxcpp/rx.hpp>

#include <tools/safecontainer.hpp>
#include <tools/scopeguard.hpp>
#include <tools/uuid.hpp>

namespace httpbusiness {

/// 获取URL的数据源：
/// 定义必须至少发射一个std::string的数据；如果遇到错误，应该
/// 至少发射一个""；
/// 获取本地路径的数据源
/// 输入应该是返回待下载的文件路径，以及一段续传base64数据；输出应该是
/// 待下载的文件路径（重命名后）；用于下载的临时文件路径，以及已传记录
/// 基于URL，需要进行获取：远端路径的实际URL（可能需要进行重定向）+ 待下载实体的体积
/// 可能有多种情况：1. 文件体积为0；2. 响应码为200，但仅trunk；3. 响应码为200，返回Content-Length;
/// 4. 响应码为206，返回Range大小；5. 非以上情况，都认为是获取远端数据的元信息失败。
/// 第一步流程：调用外部传入的Observable获取远端URL，在能获取到的情况下执行第二步；在第一步返回错误的情况下，
/// 约定：在第一步返回的任何非"http"作为起始字符串的情况下，将其视为失败，后续流程无需执行。所以第一步可以按照约定
/// 返回json封装的错误信息
/// 第二步流程：调用远端URL，获取可能重定向的最终URL，并取到文件大小
/// 成功的情况，有四种需处理；
/// 失败的情况，有两种需处理：（4xx）不应重试；（5xx）应自动重试；对网络错误，也应尽量重试。
/// 失败的情况中，对一些错误也不应重试，应提前列举出来，避免无谓的重试（比如SSL握手失败）
/// 对应进行重试，应仅重试有限的次数
/// 第三步流程：检测目标文件的文件夹路径是否存在，若不存在则创建，若创建失败则无需进一步处理，返回错误码；
/// 对没有续传base64数据的情况，要检测目标文件的临时文件是否已存在，若已存在则应重新创建直到一个新建的临时文件；
/// 对有续传base64数据的情况，直接打开目标文件的临时文件，若不可创建句柄保护，则应重新创建一个新建的临时文件并视作续传base64数据不存在
/// 第四步流程：仅在可分片的情形下，在有续传信息的情况下，根据续传信息进行重新分片处理；
/// 对各分片定义：完全成功，取下一个任务；
/// 各分片任务错误处理：无需重试的错误：4xx；可恢复的错误：206且符合契约，且已下载的内容少于契约的内容；一旦已下载的内容的最大长度有增加，应清空此错误的标记位；其他，按照指数增幅进行重试，直到达到最大重试次数。
/// 对于4xx和达到最大重试次数的情况，视为严重错误，后续都应停止。
/// 对分片成功的场景，应该把已经传成功的分片信息记录下来，以备使用；
/// 对某个分片完成但不完全成功的场景，比如：完全无需重试的错误；用户手动停止；重试达到最大重试次数，要将分片信息，和有效的下载信息保存起来。并且分片应保证未进行无效的写入。
/// TODO: 网络库的写内存映射时，在非200和206的处理时，应在内存映射对象关闭前，将其复制到容器中，将写入的内容清理掉。

}  // namespace httpbusiness

#endif  /// _RX_DOWNLOADER_HH

